C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE HSCH51
OBJECT MODULE PLACED IN .\Objects\hSch51.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE hSch51.c ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE DEBUG
                    - OBJECTEXTEND PRINT(.\Listings\hSch51.lst) TABS(3) OBJECT(.\Objects\hSch51.obj)

line level    source

   1          /*------------------------------------------------------------------*-
   2          
   3             hSCH51.C (v1.00) 
   4          
   5            ------------------------------------------------------------------
   6          
   7             /// HYBRID SCHEDULER CORE ///
   8          
   9             *** THESE ARE THE CORE SCHEDULER FUNCTIONS ***
  10             --- These functions may be used with all 8051 devices ---
  11          
  12             *** hSCH_MAX_TASKS *must* be set by the user ***
  13             --- see "Sch51.h" ---
  14          
  15             *** Includes power-saving mode ***
  16             --- You *MUST* confirm that the power-down mode is adapted ---
  17             --- to match your chosen device (usually only necessary with 
  18             --- Extended 8051s, such as c515c, c509, etc ---
  19          
  20             COPYRIGHT
  21             ---------
  22          
  23             This code is from the book:
  24          
  25             PATTERNS FOR TIME-TRIGGERED EMBEDDED SYSTEMS by Michael J. Pont 
  26             [Pearson Education, 2001; ISBN: 0-201-33138-1].
  27          
  28             This code is copyright (c) 2001 by Michael J. Pont.
  29           
  30             See book for copyright details and other information.
  31          
  32          -*------------------------------------------------------------------*/
  33          
  34          #include "Main.h"
  35          #include "Port.h"
  36          
  37          #include "hSch51.h"
  38          
  39          // ------ Public variable definitions ------------------------------
  40          
  41          // The array of tasks
  42          sTaskH hSCH_tasks_G[hSCH_MAX_TASKS];
  43          
  44          // Used to display the error code
  45          // See Main.H for details of error codes
  46          // See Port.H for details of the error port
  47          tByte Error_code_G = 0;
  48          
  49          // ------ Public variable declarations -----------------------------
  50          extern bit hSCH_sleep_EN;
  51          
  52          // ------ Private function prototypes ------------------------------
  53          
  54          
C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 2   

  55          // ------ Private variables ----------------------------------------
  56          
  57          // Keeps track of time since last error was recorded (see below)
  58          static tWord Error_tick_count_G;
  59          
  60          // The code of the last error (reset after ~1 minute)
  61          static tByte Last_error_code_G;
  62          
  63          
  64          /*------------------------------------------------------------------*-
  65          
  66            hSCH_Dispatch_Tasks()
  67          
  68            This is the 'dispatcher' function.  When a task (function)
  69            is due to run, hSCH_Dispatch_Tasks() will run it.
  70            This function must be called (repeatedly) from the main loop.
  71          
  72          -*------------------------------------------------------------------*/
  73          void hSCH_Dispatch_Tasks(void) 
  74             {
  75   1         tByte Index;
  76   1      
  77   1         // Dispatches (runs) the next task (if one is ready)
  78   1         for (Index = 0; Index < hSCH_MAX_TASKS; Index++)
  79   1            {
  80   2            // Only dispatching co-operative tasks
  81   2            if ((hSCH_tasks_G[Index].Co_op) && (hSCH_tasks_G[Index].RunMe > 0)) 
  82   2               {
  83   3               (*hSCH_tasks_G[Index].pTask)();  // Run the task
  84   3      
  85   3               hSCH_tasks_G[Index].RunMe -= 1;   // Reset / reduce RunMe flag
  86   3      
  87   3               // Periodic tasks will automatically run again
  88   3               // - if this is a 'one shot' task, remove it from the array
  89   3               if (hSCH_tasks_G[Index].Period == 0)
  90   3                  {
  91   4                  // Faster than call to delete task
  92   4                  hSCH_tasks_G[Index].pTask = 0;
  93   4                  }
  94   3               }
  95   2            }
  96   1      
  97   1         // Report system status
  98   1         hSCH_Report_Status();  
  99   1      
 100   1         // The scheduler enters idle mode at this point
 101   1         // hSCH_Go_To_Sleep();
 102   1         }
 103          
 104          /*------------------------------------------------------------------*-
 105          
 106            hSCH_Add_Task()
 107          
 108            Causes a task (function) to be executed at regular intervals 
 109            or after a user-defined delay
 110          
 111            Fn_P  - The name of the function which is to be scheduled.
 112                    NOTE: All scheduled functions must be 'void, void' -
 113                    that is, they must take no parameters, and have 
 114                    a void return type. 
 115                             
 116            Del   - The interval (TICKS) before the task is first executed
C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 3   

 117          
 118            Rep   - If 'Rep' is 0, the function is only called once,
 119                    at the time determined by 'Del'.  If Rep is non-zero,
 120                    then the function is called repeatedly at an interval
 121                    determined by the vakue of Rep (see below for examples
 122                    that should help clarify this).
 123          
 124            Co-op - Set to 1 if it a co-op task; 0 if pre-emptive
 125          
 126            RETN:   The position in the task array at which the task has been added.
 127                    If the return value is hSCH_MAX_TASKS then the task could not be
 128                    added to the array (there was insufficient space).  If the
 129                    return value is < hSCH_MAX_TASKS, then the task was added 
 130                    successfully.  
 131          
 132                    Note: this return value may be required, if a task is
 133                    to be subsequently deleted - see hSCH_Delete_Task().
 134          
 135          
 136            EXAMPLES:
 137          
 138            Task_ID = hSCH_Add_Task(Do_X,1000,0,0);
 139            Causes the function Do_X() to be executed once after 1000 ticks.
 140            (Pre-emptive task)          
 141          
 142            Task_ID = hSCH_Add_Task(Do_X,0,1000,1);
 143            Causes the function Do_X() to be executed regularly, every 1000 ticks.            
 144            (co-operative task)          
 145          
 146            Task_ID = hSCH_Add_Task(Do_X,300,1000,0);
 147            Causes the function Do_X() to be executed regularly, every 1000 ticks.
 148            Task will be first executed at T = 300 ticks, then 1300, 2300, etc.            
 149            (Pre-emptive task)          
 150           
 151          -*------------------------------------------------------------------*/
 152          tByte hSCH_Add_Task(void (code* Fn_p)(), // Task function pointer
 153                             tWord   Del,    // Num ticks 'til task first runs 
 154                             tWord   Per,    // Num ticks between repeat runs
 155                             bit     Co_op)  // Co_op / pre_emp
 156             {
 157   1         tByte Index = 0;
 158   1         
 159   1         // First find a gap in the array (if there is one)
 160   1         while ((hSCH_tasks_G[Index].pTask != 0) && (Index < hSCH_MAX_TASKS))
 161   1            {
 162   2            Index++;
 163   2            } 
 164   1         
 165   1         // Have we reached the end of the list?   
 166   1         if (Index == hSCH_MAX_TASKS)
 167   1            {
 168   2            // Task list is full
 169   2            //
 170   2            // Set the global error variable
 171   2            Error_code_G = ERROR_SCH_TOO_MANY_TASKS;
 172   2      
 173   2            // Also return an error code
 174   2            return hSCH_MAX_TASKS;  
 175   2            }
 176   1            
 177   1         // If we're here, there is a space in the task array
 178   1         hSCH_tasks_G[Index].pTask = Fn_p;
C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 4   

 179   1           
 180   1         hSCH_tasks_G[Index].Delay  = Del;
 181   1         hSCH_tasks_G[Index].Period = Per;
 182   1      
 183   1         hSCH_tasks_G[Index].Co_op = Co_op;
 184   1      
 185   1         hSCH_tasks_G[Index].RunMe  = 0;
 186   1      
 187   1         return Index; // return position of task (to allow later deletion)
 188   1         }
 189          
 190          /*------------------------------------------------------------------*-
 191          
 192            hSCH_Delete_Task()
 193          
 194            Removes a task from the scheduler.  Note that this does
 195            *not* delete the associated function from memory: 
 196            it simply means that it is no longer called by the scheduler. 
 197          
 198            PARAMS:   Task_index - The task index.  Provided by hSCH_Add_Task(). 
 199          
 200            RETURNS:  RETURN_ERROR or RETURN_NORMAL
 201          
 202          -*------------------------------------------------------------------*/
 203          bit hSCH_Delete_Task(tByte Task_index) 
 204             {
 205   1         bit Return_code;
 206   1      
 207   1         if (hSCH_tasks_G[Task_index].pTask == 0)
 208   1            {
 209   2            // No task at this location...
 210   2            //
 211   2            // Set the global error variable
 212   2            Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;
 213   2      
 214   2            // ...also return an error code
 215   2            Return_code = RETURN_ERROR;
 216   2            }
 217   1         else
 218   1            {
 219   2            Return_code = RETURN_NORMAL;
 220   2            }      
 221   1         
 222   1         hSCH_tasks_G[Task_index].pTask   = 0;
 223   1         hSCH_tasks_G[Task_index].Delay   = 0;
 224   1         hSCH_tasks_G[Task_index].Period  = 0;
 225   1      
 226   1         hSCH_tasks_G[Task_index].RunMe   = 0;
 227   1      
 228   1         return Return_code;       // return status
 229   1         }
 230          
 231          
 232          /*------------------------------------------------------------------*-
 233          
 234            hSCH_Report_Status()
 235          
 236            Simple function to display error codes.
 237          
 238            This version displays code on a port with attached LEDs:
 239            adapt, if required, to report errors over serial link, etc.
 240          
C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 5   

 241            Errors are only displayed for a limited period 
 242            (60000 ticks = 1 minute at 1ms tick interval).
 243            After this the the error code is reset to 0. 
 244          
 245            This code may be easily adapted to display the last
 246            error 'for ever': this may be appropriate in your
 247            application.
 248          
 249            See Chapter 14 for further information.
 250           
 251          -*------------------------------------------------------------------*/
 252          void hSCH_Report_Status(void)
 253             {
 254   1      #ifdef SCH_REPORT_ERRORS
                 // ONLY APPLIES IF WE ARE REPORTING ERRORS
                 // Check for a new error code
                 if (Error_code_G != Last_error_code_G)
                    {
                    // Negative logic on LEDs assumed
                    Error_port = 255 - Error_code_G;
                    
                    Last_error_code_G = Error_code_G;
              
                    if (Error_code_G != 0)
                       {
                       Error_tick_count_G = 60000;
                       }
                    else
                       {
                       Error_tick_count_G = 0;
                       }
                    }
                 else
                    {
                    if (Error_tick_count_G != 0)
                       {
                       if (--Error_tick_count_G == 0)
                          {
                          Error_code_G = 0; // Reset error code
                          }
                       }
                    }
              #endif
 284   1         }
 285          
 286          
 287          /*------------------------------------------------------------------*-
 288          
 289            hSCH_Go_To_Sleep()
 290          
 291            This scheduler enters 'idle mode' between clock ticks
 292            to save power.  The next clock tick will return the processor
 293            to the normal operating state.
 294          
 295            Note: a slight performance improvement is possible if this
 296            function is implemented as a macro, or if the code here is simply 
 297            pasted into the 'dispatch' function.  
 298          
 299            However, by making this a function call, it becomes easier 
 300            - during development - to assess the performance of the 
 301            scheduler, using the 'performance analyser' in the Keil 
 302            hardware simulator. See Chapter 14 for examples for this. 
C51 COMPILER V9.54   HSCH51                                                                06/16/2016 11:58:36 PAGE 6   

 303          
 304            *** May wish to disable this if using a watchdog ***
 305          
 306            *** ADAPT AS REQUIRED FOR YOUR HARDWARE ***
 307          
 308          -*------------------------------------------------------------------*/
 309          void hSCH_Go_To_Sleep()
 310             {
 311   1      // PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 312   1         PCON |= 0x02;    // Enter power down mode (generic 8051 version)
 313   1      
 314   1         // Entering idle mode requires TWO consecutive instructions 
 315   1         // on 80c515 / 80c505 - to avoid accidental triggering
 316   1         //PCON |= 0x01;    // Enter idle mode (#1)
 317   1         //PCON |= 0x20;    // Enter idle mode (#2)
 318   1         }
 319          
 320          
 321          /*------------------------------------------------------------------*-
 322            ---- END OF FILE -------------------------------------------------
 323          -*------------------------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    284    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
