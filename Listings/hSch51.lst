C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE HSCH51
OBJECT MODULE PLACED IN .\Objects\hSch51.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE hSch51.c ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE DEBUG
                    - OBJECTEXTEND PRINT(.\Listings\hSch51.lst) TABS(3) OBJECT(.\Objects\hSch51.obj)

line level    source

   1          /*------------------------------------------------------------------*-
   2          
   3             hSCH51.C (v1.00) 
   4          
   5            ------------------------------------------------------------------
   6          
   7             /// HYBRID SCHEDULER CORE ///
   8          
   9             *** THESE ARE THE CORE SCHEDULER FUNCTIONS ***
  10             --- These functions may be used with all 8051 devices ---
  11          
  12             *** hSCH_MAX_TASKS *must* be set by the user ***
  13             --- see "Sch51.h" ---
  14          
  15             *** Includes power-saving mode ***
  16             --- You *MUST* confirm that the power-down mode is adapted ---
  17             --- to match your chosen device (usually only necessary with 
  18             --- Extended 8051s, such as c515c, c509, etc ---
  19          
  20             COPYRIGHT
  21             ---------
  22          
  23             This code is from the book:
  24          
  25             PATTERNS FOR TIME-TRIGGERED EMBEDDED SYSTEMS by Michael J. Pont 
  26             [Pearson Education, 2001; ISBN: 0-201-33138-1].
  27          
  28             This code is copyright (c) 2001 by Michael J. Pont.
  29           
  30             See book for copyright details and other information.
  31          
  32          -*------------------------------------------------------------------*/
  33          
  34          #include "Main.h"
  35          #include "Port.h"
  36          
  37          #include "hSch51.h"
  38          
  39          // ------ Public variable definitions ------------------------------
  40          
  41          // The array of tasks
  42          sTaskH hSCH_tasks_G[hSCH_MAX_TASKS];
  43          
  44          // Used to display the error code
  45          // See Main.H for details of error codes
  46          // See Port.H for details of the error port
  47          tByte Error_code_G = 0;
  48          
  49          // ------ Public variable declarations -----------------------------
  50          extern bit hSCH_sleep_EN;
  51          
  52          // ------ Private function prototypes ------------------------------
  53          
  54          
C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 2   

  55          // ------ Private variables ----------------------------------------
  56          
  57          // Keeps track of time since last error was recorded (see below)
  58          static tWord Error_tick_count_G;
  59          
  60          // The code of the last error (reset after ~1 minute)
  61          static tByte Last_error_code_G;
  62          
  63          
  64          /*------------------------------------------------------------------*-
  65          
  66            hSCH_Dispatch_Tasks()
  67          
  68            This is the 'dispatcher' function.  When a task (function)
  69            is due to run, hSCH_Dispatch_Tasks() will run it.
  70            This function must be called (repeatedly) from the main loop.
  71          
  72          -*------------------------------------------------------------------*/
  73          void hSCH_Dispatch_Tasks(void) 
  74             {
  75   1         tByte Index;
  76   1      
  77   1         // Dispatches (runs) the next task (if one is ready)
  78   1         for (Index = 0; Index < hSCH_MAX_TASKS; Index++)
  79   1            {
  80   2            // Only dispatching co-operative tasks
  81   2            if ((hSCH_tasks_G[Index].Co_op) && (hSCH_tasks_G[Index].RunMe > 0)) 
  82   2               {
  83   3               (*hSCH_tasks_G[Index].pTask)();  // Run the task
  84   3      
  85   3               hSCH_tasks_G[Index].RunMe -= 1;   // Reset / reduce RunMe flag
  86   3      
  87   3               // Periodic tasks will automatically run again
  88   3               // - if this is a 'one shot' task, remove it from the array
  89   3               if (hSCH_tasks_G[Index].Period == 0)
  90   3                  {
  91   4                  // Faster than call to delete task
  92   4                  hSCH_tasks_G[Index].pTask = 0;
  93   4                  }
  94   3               }
  95   2            }
  96   1      
  97   1         // Report system status
  98   1         hSCH_Report_Status();  
  99   1      
 100   1         // The scheduler enters idle mode at this point 
 101   1         }
 102          
 103          /*------------------------------------------------------------------*-
 104          
 105            hSCH_Add_Task()
 106          
 107            Causes a task (function) to be executed at regular intervals 
 108            or after a user-defined delay
 109          
 110            Fn_P  - The name of the function which is to be scheduled.
 111                    NOTE: All scheduled functions must be 'void, void' -
 112                    that is, they must take no parameters, and have 
 113                    a void return type. 
 114                             
 115            Del   - The interval (TICKS) before the task is first executed
 116          
C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 3   

 117            Rep   - If 'Rep' is 0, the function is only called once,
 118                    at the time determined by 'Del'.  If Rep is non-zero,
 119                    then the function is called repeatedly at an interval
 120                    determined by the vakue of Rep (see below for examples
 121                    that should help clarify this).
 122          
 123            Co-op - Set to 1 if it a co-op task; 0 if pre-emptive
 124          
 125            RETN:   The position in the task array at which the task has been added.
 126                    If the return value is hSCH_MAX_TASKS then the task could not be
 127                    added to the array (there was insufficient space).  If the
 128                    return value is < hSCH_MAX_TASKS, then the task was added 
 129                    successfully.  
 130          
 131                    Note: this return value may be required, if a task is
 132                    to be subsequently deleted - see hSCH_Delete_Task().
 133          
 134          
 135            EXAMPLES:
 136          
 137            Task_ID = hSCH_Add_Task(Do_X,1000,0,0);
 138            Causes the function Do_X() to be executed once after 1000 ticks.
 139            (Pre-emptive task)          
 140          
 141            Task_ID = hSCH_Add_Task(Do_X,0,1000,1);
 142            Causes the function Do_X() to be executed regularly, every 1000 ticks.            
 143            (co-operative task)          
 144          
 145            Task_ID = hSCH_Add_Task(Do_X,300,1000,0);
 146            Causes the function Do_X() to be executed regularly, every 1000 ticks.
 147            Task will be first executed at T = 300 ticks, then 1300, 2300, etc.            
 148            (Pre-emptive task)          
 149           
 150          -*------------------------------------------------------------------*/
 151          tByte hSCH_Add_Task(void (code* Fn_p)(), // Task function pointer
 152                             tWord   Del,    // Num ticks 'til task first runs 
 153                             tWord   Per,    // Num ticks between repeat runs
 154                             bit     Co_op)  // Co_op / pre_emp
 155             {
 156   1         tByte Index = 0;
 157   1         
 158   1         // First find a gap in the array (if there is one)
 159   1         while ((hSCH_tasks_G[Index].pTask != 0) && (Index < hSCH_MAX_TASKS))
 160   1            {
 161   2            Index++;
 162   2            } 
 163   1         
 164   1         // Have we reached the end of the list?   
 165   1         if (Index == hSCH_MAX_TASKS)
 166   1            {
 167   2            // Task list is full
 168   2            //
 169   2            // Set the global error variable
 170   2            Error_code_G = ERROR_SCH_TOO_MANY_TASKS;
 171   2      
 172   2            // Also return an error code
 173   2            return hSCH_MAX_TASKS;  
 174   2            }
 175   1            
 176   1         // If we're here, there is a space in the task array
 177   1         hSCH_tasks_G[Index].pTask = Fn_p;
 178   1           
C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 4   

 179   1         hSCH_tasks_G[Index].Delay  = Del;
 180   1         hSCH_tasks_G[Index].Period = Per;
 181   1      
 182   1         hSCH_tasks_G[Index].Co_op = Co_op;
 183   1      
 184   1         hSCH_tasks_G[Index].RunMe  = 0;
 185   1      
 186   1         return Index; // return position of task (to allow later deletion)
 187   1         }
 188          
 189          /*------------------------------------------------------------------*-
 190          
 191            hSCH_Delete_Task()
 192          
 193            Removes a task from the scheduler.  Note that this does
 194            *not* delete the associated function from memory: 
 195            it simply means that it is no longer called by the scheduler. 
 196          
 197            PARAMS:   Task_index - The task index.  Provided by hSCH_Add_Task(). 
 198          
 199            RETURNS:  RETURN_ERROR or RETURN_NORMAL
 200          
 201          -*------------------------------------------------------------------*/
 202          bit hSCH_Delete_Task(tByte Task_index) 
 203             {
 204   1         bit Return_code;
 205   1      
 206   1         if (hSCH_tasks_G[Task_index].pTask == 0)
 207   1            {
 208   2            // No task at this location...
 209   2            //
 210   2            // Set the global error variable
 211   2            Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;
 212   2      
 213   2            // ...also return an error code
 214   2            Return_code = RETURN_ERROR;
 215   2            }
 216   1         else
 217   1            {
 218   2            Return_code = RETURN_NORMAL;
 219   2            }      
 220   1         
 221   1         hSCH_tasks_G[Task_index].pTask   = 0;
 222   1         hSCH_tasks_G[Task_index].Delay   = 0;
 223   1         hSCH_tasks_G[Task_index].Period  = 0;
 224   1      
 225   1         hSCH_tasks_G[Task_index].RunMe   = 0;
 226   1      
 227   1         return Return_code;       // return status
 228   1         }
 229          
 230          
 231          /*------------------------------------------------------------------*-
 232          
 233            hSCH_Report_Status()
 234          
 235            Simple function to display error codes.
 236          
 237            This version displays code on a port with attached LEDs:
 238            adapt, if required, to report errors over serial link, etc.
 239          
 240            Errors are only displayed for a limited period 
C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 5   

 241            (60000 ticks = 1 minute at 1ms tick interval).
 242            After this the the error code is reset to 0. 
 243          
 244            This code may be easily adapted to display the last
 245            error 'for ever': this may be appropriate in your
 246            application.
 247          
 248            See Chapter 14 for further information.
 249           
 250          -*------------------------------------------------------------------*/
 251          void hSCH_Report_Status(void)
 252             {
 253   1      #ifdef SCH_REPORT_ERRORS
                 // ONLY APPLIES IF WE ARE REPORTING ERRORS
                 // Check for a new error code
                 if (Error_code_G != Last_error_code_G)
                    {
                    // Negative logic on LEDs assumed
                    Error_port = 255 - Error_code_G;
                    
                    Last_error_code_G = Error_code_G;
              
                    if (Error_code_G != 0)
                       {
                       Error_tick_count_G = 60000;
                       }
                    else
                       {
                       Error_tick_count_G = 0;
                       }
                    }
                 else
                    {
                    if (Error_tick_count_G != 0)
                       {
                       if (--Error_tick_count_G == 0)
                          {
                          Error_code_G = 0; // Reset error code
                          }
                       }
                    }
              #endif
 283   1         }
 284          
 285          
 286          /*------------------------------------------------------------------*-
 287          
 288            hSCH_Go_To_Sleep()
 289          
 290            This scheduler enters 'idle mode' between clock ticks
 291            to save power.  The next clock tick will return the processor
 292            to the normal operating state.
 293          
 294            Note: a slight performance improvement is possible if this
 295            function is implemented as a macro, or if the code here is simply 
 296            pasted into the 'dispatch' function.  
 297          
 298            However, by making this a function call, it becomes easier 
 299            - during development - to assess the performance of the 
 300            scheduler, using the 'performance analyser' in the Keil 
 301            hardware simulator. See Chapter 14 for examples for this. 
 302          
C51 COMPILER V9.54   HSCH51                                                                04/22/2016 14:54:23 PAGE 6   

 303            *** May wish to disable this if using a watchdog ***
 304          
 305            *** ADAPT AS REQUIRED FOR YOUR HARDWARE ***
 306          
 307          -*------------------------------------------------------------------*/
 308          void hSCH_Go_To_Sleep()
 309             {
 310   1         PCON |= 0x02;    // Enter idle mode (generic 8051 version)
 311   1      
 312   1         // Entering idle mode requires TWO consecutive instructions 
 313   1         // on 80c515 / 80c505 - to avoid accidental triggering
 314   1         //PCON |= 0x01;    // Enter idle mode (#1)
 315   1         //PCON |= 0x20;    // Enter idle mode (#2)
 316   1         }
 317          
 318          
 319          /*------------------------------------------------------------------*-
 320            ---- END OF FILE -------------------------------------------------
 321          -*------------------------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    284    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
